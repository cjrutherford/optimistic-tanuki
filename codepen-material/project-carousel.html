<head>
  <style>
    /* Enhanced futuristic styling */
    :root {
      --glow-primary: rgba(56, 189, 248, 0.7);
      --glow-secondary: rgba(94, 234, 212, 0.6);
      --neon-pink: rgba(236, 72, 153, 0.8);
      --neon-blue: rgba(59, 130, 246, 0.8);
      --neon-green: rgba(16, 185, 129, 0.8);
    }

    body {
      font-family: 'Exo 2', sans-serif;
      background: radial-gradient(circle at center, #0f172a, #020617);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      position: relative;
    }

    /* Background grid effect */
    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: linear-gradient(
          rgba(14, 165, 233, 0.1) 1px,
          transparent 1px
        ),
        linear-gradient(90deg, rgba(14, 165, 233, 0.1) 1px, transparent 1px);
      background-size: 40px 40px;
      background-position: center center;
      perspective: 1000px;
      transform-style: preserve-3d;
      animation: gridMove 60s linear infinite;
    }

    @keyframes gridMove {
      0% {
        background-position: 0px 0px;
        opacity: 0.5;
      }
      50% {
        opacity: 0.2;
      }
      100% {
        background-position: 40px 40px;
        opacity: 0.5;
      }
    }

    .carousel-container {
      width: 90%;
      max-width: 1100px;
      position: relative;
      perspective: 2000px;
      padding: 3rem 0;
      z-index: 10;
    }

    .carousel-track {
      display: flex;
      transition: transform 0.75s cubic-bezier(0.21, 0.61, 0.35, 1);
      transform-style: preserve-3d;
    }

    .carousel-card {
      min-width: 320px;
      max-width: 320px;
      margin: 0 25px;
      background: linear-gradient(
        135deg,
        rgba(30, 41, 59, 0.85),
        rgba(15, 23, 42, 0.9)
      );
      border-radius: 1.2rem;
      overflow: hidden;
      backdrop-filter: blur(10px);
      box-shadow: 0 15px 25px rgba(0, 0, 0, 0.5),
        0 0 30px rgba(56, 189, 248, 0.2);
      transition: all 0.6s cubic-bezier(0.21, 0.61, 0.35, 1);
      transform-origin: center center;
      position: relative;
      border: 1px solid rgba(94, 234, 212, 0.2);
    }

    /* Holographic border effect */
    .carousel-card::before {
      content: '';
      position: absolute;
      inset: -2px;
      background: linear-gradient(
        45deg,
        transparent 0%,
        var(--neon-blue) 25%,
        var(--neon-green) 50%,
        var(--neon-pink) 75%,
        transparent 100%
      );
      z-index: -1;
      border-radius: 1.3rem;
      filter: blur(8px);
      opacity: 0;
      transition: opacity 0.5s ease;
      animation: borderGlow 6s linear infinite;
    }

    @keyframes borderGlow {
      0% {
        background-position: 0% 50%;
        opacity: 0.3;
      }
      50% {
        background-position: 100% 50%;
        opacity: 0.5;
      }
      100% {
        background-position: 0% 50%;
        opacity: 0.3;
      }
    }

    .carousel-card.is-active::before {
      opacity: 1;
      background-size: 300% 300%;
    }

    .carousel-card:not(.is-active) {
      transform: scale(0.8) rotateY(35deg) translateZ(-100px);
      opacity: 0.45;
      filter: saturate(0.6) brightness(0.7);
    }

    .carousel-card.is-prev {
      transform-origin: right center;
      transform: scale(0.75) rotateY(45deg) translateX(-80px) translateZ(-150px);
    }

    .carousel-card.is-next {
      transform-origin: left center;
      transform: scale(0.75) rotateY(-45deg) translateX(80px) translateZ(-150px);
    }

    .carousel-card.is-active {
      transform: scale(1) rotateY(0) translateZ(0);
      opacity: 1;
      z-index: 20;
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5), 0 0 40px var(--glow-primary),
        inset 0 0 20px rgba(56, 189, 248, 0.1);
      filter: saturate(1.2) brightness(1.1);
    }

    .card-image-container {
      position: relative;
      height: 200px;
      overflow: hidden;
      border-bottom: 1px solid rgba(94, 234, 212, 0.3);
    }

    .card-image {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 1.5s ease;
    }

    .carousel-card.is-active .card-image {
      transform: scale(1.05);
    }

    /* HUD overlay effect on images */
    .card-image-container::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(
          120deg,
          rgba(56, 189, 248, 0.1),
          transparent 70%
        ),
        radial-gradient(
          circle at 80% 20%,
          rgba(94, 234, 212, 0.15),
          transparent 50%
        );
      pointer-events: none;
    }

    /* Scan line effect */
    .card-image-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: repeating-linear-gradient(
        0deg,
        rgba(6, 182, 212, 0.05) 0px,
        rgba(6, 182, 212, 0.05) 1px,
        transparent 1px,
        transparent 4px
      );
      pointer-events: none;
      opacity: 0.5;
      z-index: 5;
    }

    .card-content {
      padding: 1.75rem;
      color: #f1f5f9;
    }

    .card-title {
      font-family: 'Orbitron', sans-serif;
      margin-bottom: 0.75rem;
      letter-spacing: 1px;
      position: relative;
      display: inline-block;
    }

    /* Text glow effect */
    .card-title::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      color: transparent;
      -webkit-text-stroke: 0.5px;
      filter: blur(3px);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .carousel-card.is-active .card-title::after {
      opacity: 0.8;
    }

    .card-description {
      font-size: 0.9rem;
      line-height: 1.6;
      color: rgba(241, 245, 249, 0.8);
      font-weight: 300;
    }

    /* HUD-style progress bar */
    .card-progress {
      height: 3px;
      background: rgba(56, 189, 248, 0.15);
      margin-top: 1.25rem;
      position: relative;
      border-radius: 4px;
      overflow: hidden;
    }

    .progress-value {
      position: absolute;
      height: 100%;
      background: linear-gradient(90deg, var(--neon-blue), var(--neon-green));
      border-radius: 4px;
      width: 75%;
    }

    .card-stats {
      display: flex;
      justify-content: space-between;
      margin-top: 0.5rem;
      font-size: 0.7rem;
      color: rgba(241, 245, 249, 0.6);
    }

    /* Futuristic navigation buttons */
    .carousel-button {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(12, 74, 110, 0.3);
      color: #38bdf8;
      border: 1px solid rgba(14, 165, 233, 0.4);
      border-radius: 50%;
      width: 48px;
      height: 48px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      z-index: 20;
      transition: all 0.3s ease;
      backdrop-filter: blur(5px);
      box-shadow: 0 0 15px rgba(56, 189, 248, 0.2);
    }

    .carousel-button:hover {
      background-color: rgba(14, 165, 233, 0.3);
      color: #e0f2fe;
      transform: translateY(-50%) scale(1.1);
      box-shadow: 0 0 20px rgba(56, 189, 248, 0.4);
    }

    .carousel-button:active {
      transform: translateY(-50%) scale(0.95);
    }

    /* Button hover effect */
    .carousel-button::before {
      content: '';
      position: absolute;
      inset: -2px;
      background: radial-gradient(circle, var(--neon-blue), transparent 70%);
      border-radius: 50%;
      opacity: 0;
      z-index: -1;
      transition: opacity 0.3s ease;
    }

    .carousel-button:hover::before {
      opacity: 0.7;
      animation: pulseGlow 2s infinite;
    }

    @keyframes pulseGlow {
      0% {
        transform: scale(1);
        opacity: 0.7;
      }
      50% {
        transform: scale(1.2);
        opacity: 0.3;
      }
      100% {
        transform: scale(1);
        opacity: 0.7;
      }
    }

    .carousel-button.prev {
      left: -24px;
    }

    .carousel-button.next {
      right: -24px;
    }

    /* Indicator dots */
    .carousel-indicators {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 2rem;
    }

    .indicator {
      width: 24px;
      height: 4px;
      background: rgba(56, 189, 248, 0.2);
      border-radius: 2px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .indicator.active {
      background: #38bdf8;
      box-shadow: 0 0 10px #38bdf8;
    }

    /* Tech details overlay */
    .tech-details {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(15, 23, 42, 0.85);
      backdrop-filter: blur(10px);
      padding: 0.75rem;
      transform: translateY(100%);
      transition: transform 0.4s cubic-bezier(0.21, 0.61, 0.35, 1);
      z-index: 25;
      border-top: 1px solid rgba(94, 234, 212, 0.3);
    }

    .carousel-card.is-active:hover .tech-details {
      transform: translateY(0);
    }

    .tech-tag {
      display: inline-block;
      margin-right: 8px;
      margin-bottom: 8px;
      padding: 4px 8px;
      font-size: 0.7rem;
      background: rgba(56, 189, 248, 0.15);
      border: 1px solid rgba(56, 189, 248, 0.3);
      border-radius: 4px;
      color: #7dd3fc;
    }

    .is-far-next {
      transform: scale(0.8) rotateY(-45deg) translateZ(-100px) !important;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .carousel-button {
        width: 40px;
        height: 40px;
      }

      .carousel-button.prev {
        left: 5px;
      }

      .carousel-button.next {
        right: 5px;
      }

      .carousel-card {
        min-width: 260px;
        max-width: 260px;
        margin: 0 15px;
      }

      .carousel-card:not(.is-active) {
        transform: scale(0.85) rotateY(25deg);
      }

      .carousel-card.is-prev {
        transform: scale(0.8) rotateY(30deg) translateX(-40px);
      }

      .carousel-card.is-next {
        transform: scale(0.8) rotateY(-30deg) translateX(40px);
      }

      .card-image-container {
        height: 160px;
      }
    }
  </style>
  <script>
    const track = document.querySelector('.carousel-track');
    const cards = Array.from(track.children);
    const nextButton = document.querySelector('.carousel-button.next');
    const prevButton = document.querySelector('.carousel-button.prev');
    const container = document.querySelector('.carousel-container');
    const indicators = document.querySelectorAll('.indicator');

    let currentIndex = 0;
    let cardWidth = cards[0].offsetWidth;
    let cardMargin =
      parseInt(window.getComputedStyle(cards[0]).marginRight) * 2;

    // Debounce function
    function debounce(func, wait, immediate) {
      var timeout;
      return function () {
        var context = this,
          args = arguments;
        var later = function () {
          timeout = null;
          if (!immediate) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
      };
    }

    // Initialize carousel
    function initializeCarousel() {
      cardWidth = cards[0].offsetWidth;
      cardMargin = parseInt(window.getComputedStyle(cards[0]).marginRight) * 2;

      // Center the initial card
      const initialOffset = container.offsetWidth / 2 - cardWidth / 2;
      track.style.transform = `translateX(${initialOffset}px)`;
      updateCarousel();
    }

    // Update carousel state
    function updateCarousel() {
      // Update card classes
      cards.forEach((card, index) => {
        card.classList.remove(
          'is-active',
          'is-prev',
          'is-next',
          'is-far-prev',
          'is-far-next'
        );

        if (index === currentIndex) {
          card.classList.add('is-active');
        } else if (index === currentIndex - 1) {
          card.classList.add('is-prev');
        } else if (index === currentIndex + 1) {
          card.classList.add('is-next');
        } else if (index < currentIndex - 1) {
          card.classList.add('is-far-prev');
        } else if (index > currentIndex + 1) {
          card.classList.add('is-far-next');
        }
      });

      // Update indicators
      indicators.forEach((indicator, index) => {
        indicator.classList.toggle('active', index === currentIndex);
      });
    }

    // Move to a specific slide
    function moveToSlide(targetIndex) {
      if (targetIndex < 0 || targetIndex >= cards.length) {
        return; // Prevent moving out of bounds
      }

      const amountToMove = targetIndex * (cardWidth + cardMargin);
      const containerCenter = container.offsetWidth / 2;
      const cardCenter = cardWidth / 2;
      const targetTranslateX = containerCenter - cardCenter - amountToMove;

      track.style.transform = `translateX(${targetTranslateX - 25}px)`;
      currentIndex = targetIndex;
      updateCarousel();

      // Add a subtle flash effect to simulate a hi-tech transition
      const flashEffect = document.createElement('div');
      flashEffect.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(56, 189, 248, 0.1);
                z-index: 30;
                pointer-events: none;
                opacity: 0;
                transition: opacity 0.2s ease;
            `;
      container.appendChild(flashEffect);

      setTimeout(() => {
        flashEffect.style.opacity = '0.3';
        setTimeout(() => {
          flashEffect.style.opacity = '0';
          setTimeout(() => {
            container.removeChild(flashEffect);
          }, 200);
        }, 100);
      }, 10);
    }

    // Event Listeners
    nextButton.addEventListener('click', () => {
      const nextIndex = currentIndex + 1;
      if (nextIndex < cards.length) {
        moveToSlide(nextIndex);
      }
    });

    prevButton.addEventListener('click', () => {
      const prevIndex = currentIndex - 1;
      if (prevIndex >= 0) {
        moveToSlide(prevIndex);
      }
    });

    // Indicator clicks
    indicators.forEach((indicator, index) => {
      indicator.addEventListener('click', () => {
        moveToSlide(index);
      });
    });

    // Swipe Functionality
    let isDragging = false;
    let startPos = 0;
    let currentTranslate = 0;
    let prevTranslate = 0;
    let animationID;

    track.addEventListener('mousedown', dragStart);
    track.addEventListener('touchstart', dragStart, { passive: true });

    track.addEventListener('mousemove', drag);
    track.addEventListener('touchmove', drag, { passive: true });

    track.addEventListener('mouseup', dragEnd);
    track.addEventListener('mouseleave', dragEnd);
    track.addEventListener('touchend', dragEnd);

    function dragStart(event) {
      isDragging = true;
      startPos = getPositionX(event);

      // Get current transform value
      const transformMatrix = window
        .getComputedStyle(track)
        .getPropertyValue('transform');
      if (transformMatrix !== 'none') {
        currentTranslate = parseInt(transformMatrix.split(',')[4]);
      } else {
        currentTranslate = 0;
      }
      prevTranslate = currentTranslate;
      track.style.transition = 'none';
      animationID = requestAnimationFrame(animation);
      track.style.cursor = 'grabbing';
    }

    function drag(event) {
      if (isDragging) {
        const currentPosition = getPositionX(event);
        const moveX = currentPosition - startPos;
        currentTranslate = prevTranslate + moveX;
      }
    }

    function animation() {
      if (!isDragging) return;
      track.style.transform = `translateX(${currentTranslate}px)`;
      requestAnimationFrame(animation);
    }

    function dragEnd() {
      if (!isDragging) return;

      cancelAnimationFrame(animationID);
      isDragging = false;
      const movedBy = currentTranslate - prevTranslate;
      track.style.transition =
        'transform 0.75s cubic-bezier(0.21, 0.61, 0.35, 1)';
      track.style.cursor = 'grab';

      // Determine whether to snap to next/prev slide
      const threshold = cardWidth / 3.5; // Less distance needed to trigger slide change

      if (movedBy < -threshold && currentIndex < cards.length - 1) {
        moveToSlide(currentIndex + 1);
      } else if (movedBy > threshold && currentIndex > 0) {
        moveToSlide(currentIndex - 1);
      } else {
        moveToSlide(currentIndex); // Snap back
      }
    }

    function getPositionX(event) {
      return event.type.includes('mouse')
        ? event.pageX
        : event.touches[0].clientX;
    }

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
        if (currentIndex < cards.length - 1) {
          moveToSlide(currentIndex + 1);
        }
      } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
        if (currentIndex > 0) {
          moveToSlide(currentIndex - 1);
        }
      }
    });

    // Window resize handler
    window.addEventListener(
      'resize',
      debounce(() => {
        initializeCarousel();
        moveToSlide(currentIndex);
      }, 250)
    );

    // Add automatic card hover effects
    cards.forEach((card) => {
      // Create glitch effect on hover
      card.addEventListener('mouseenter', function () {
        if (!card.classList.contains('is-active')) return;

        // Create glitch animation
        const glitchEffect = () => {
          if (!card.matches(':hover') || !card.classList.contains('is-active'))
            return;

          // Random offset
          const xOffset = Math.random() * 4 - 2;
          const yOffset = Math.random() * 4 - 2;

          card.style.transform = `scale(1) translate(${xOffset}px, ${yOffset}px)`;

          // Random color channel shift
          const r = Math.random() * 10 - 5;
          const g = Math.random() * 10 - 5;
          const b = Math.random() * 10 - 5;

          card.style.boxShadow = `
                        ${r}px 0 0 rgba(255, 0, 0, 0.2),
                        ${g}px 0 0 rgba(0, 255, 0, 0.2),
                        ${b}px 0 0 rgba(0, 0, 255, 0.2),
                        0 15px 25px rgba(0, 0, 0, 0.5),
                        0 0 40px var(--glow-primary)
                    `;

          // Reset after short time
          setTimeout(() => {
            if (
              !card.matches(':hover') ||
              !card.classList.contains('is-active')
            )
              return;
            // card.style.transform = 'scale(1)';
            card.style.boxShadow =
              '0 15px 25px rgba(0, 0, 0, 0.5), 0 0 40px var(--glow-primary)';
          }, 50);

          // Continue effect randomly while hovering
          if (Math.random() > 0.7) {
            setTimeout(glitchEffect, Math.random() * 1000 + 500);
          }
        };

        // Start glitch effect chain
        setTimeout(glitchEffect, 500);
      });

      // Reset styles on mouse leave
      card.addEventListener('mouseleave', function () {
        if (card.classList.contains('is-active')) {
          card.style.boxShadow =
            '0 15px 25px rgba(0, 0, 0, 0.5), 0 0 40px var(--glow-primary)';
        }
      });
    });

    // Add HUD scanning animation to active card
    function animateActiveCard() {
      const activeCard = document.querySelector('.carousel-card.is-active');
      if (!activeCard) return;

      // Add scanning line effect
      const scanLine = document.createElement('div');
      scanLine.style.cssText = `
                position: absolute;
                left: 0;
                top: 0;
                height: 2px;
                width: 100%;
                background: linear-gradient(90deg, 
                    transparent, 
                    rgba(56, 189, 248, 0.8), 
                    rgba(56, 189, 248, 0.8), 
                    transparent
                );
                opacity: 0.7;
                z-index: 10;
                pointer-events: none;
                animation: scanAnimation 2s ease-in-out;
            `;

      // Define animation
      const style = document.createElement('style');
      style.textContent = `
                @keyframes scanAnimation {
                    0% { top: 0; }
                    75% { top: calc(100% - 2px); }
                    100% { top: calc(100% - 2px); opacity: 0; }
                }
            `;
      document.head.appendChild(style);

      // Add to active card and remove when animation completes
      const imageContainer = activeCard.querySelector('.card-image-container');
      imageContainer.appendChild(scanLine);

      setTimeout(() => {
        imageContainer.removeChild(scanLine);
      }, 2000);
    }

    // Add data counter animation effect
    function animateDataCounter() {
      const activeCard = document.querySelector('.carousel-card.is-active');
      if (!activeCard) return;

      const statsElement = activeCard.querySelector('.card-stats');
      const completionText = statsElement.lastElementChild.textContent;
      const percentageMatch = completionText.match(/(\d+)%/);

      if (percentageMatch) {
        const targetPercentage = parseInt(percentageMatch[1]);
        let currentPercentage = 0;

        statsElement.lastElementChild.textContent = '0% COMPLETE';

        const interval = setInterval(() => {
          currentPercentage += Math.ceil(targetPercentage / 15);

          if (currentPercentage >= targetPercentage) {
            currentPercentage = targetPercentage;
            clearInterval(interval);
          }

          statsElement.lastElementChild.textContent = `${currentPercentage}% COMPLETE`;
        }, 50);

        // Also animate progress bar
        const progressBar = activeCard.querySelector('.progress-value');
        progressBar.style.width = '0%';

        setTimeout(() => {
          progressBar.style.transition =
            'width 0.8s cubic-bezier(0.17, 0.67, 0.83, 0.67)';
          progressBar.style.width = `${targetPercentage}%`;
        }, 100);
      }
    }

    // Update active card when changed
    function handleCardActivation() {
      animateActiveCard();
      animateDataCounter();

      // Reset progress bar transition after animation completes
      setTimeout(() => {
        const progressBars = document.querySelectorAll('.progress-value');
        progressBars.forEach((bar) => {
          bar.style.transition = 'none';
        });
      }, 1000);
    }

    // Add subtle floating animation to all cards
    function addFloatingEffect() {
      cards.forEach((card, index) => {
        const delay = index * 0.2;
        card.style.animation = `floating 4s ease-in-out ${delay}s infinite`;
      });

      const floatingKeyframes = `
                @keyframes floating {
                    0% { transform: translateY(0px) rotate3d(0, 1, 0, 0deg); }
                    50% { transform: translateY(-10px) rotate3d(0, 1, 0, 1deg); }
                    100% { transform: translateY(0px) rotate3d(0, 1, 0, 0deg); }
                }
            `;

      const style = document.createElement('style');
      style.textContent = floatingKeyframes;
      document.head.appendChild(style);
    }

    // Add observer to detect active card changes
    let previousActive = null;

    // Create a mutation observer to watch for class changes
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === 'class') {
          const target = mutation.target;
          if (
            target.classList.contains('is-active') &&
            target !== previousActive
          ) {
            previousActive = target;
            handleCardActivation();
          }
        }
      });
    });

    // Start observing all cards for class changes
    cards.forEach((card) => {
      observer.observe(card, { attributes: true });
    });

    // Add keyboard navigation animation feedback
    document.addEventListener('keydown', (e) => {
      if (
        e.key === 'ArrowRight' ||
        e.key === 'ArrowLeft' ||
        e.key === 'ArrowUp' ||
        e.key === 'ArrowDown'
      ) {
        // Create a brief flash effect on button
        const button =
          e.key === 'ArrowRight' || e.key === 'ArrowDown'
            ? nextButton
            : prevButton;

        button.style.transform = 'translateY(-50%) scale(1.2)';
        button.style.boxShadow = '0 0 30px var(--glow-primary)';

        setTimeout(() => {
          button.style.transform = 'translateY(-50%) scale(1)';
          button.style.boxShadow = '';
        }, 200);
      }
    });

    // Add initialization for indicator animations
    indicators.forEach((indicator, index) => {
      indicator.addEventListener('click', function () {
        // Add pulse effect when clicked
        this.style.transform = 'scale(1.3)';
        this.style.boxShadow = '0 0 15px #38bdf8';

        setTimeout(() => {
          this.style.transform = '';
          this.style.boxShadow = '';
        }, 300);
      });
    });

    // Initialize everything
    window.onload = () => {
      initializeCarousel();

      // Set initial active state
      moveToSlide(2);

      // Start animations with slight delay
      setTimeout(() => {
        // addFloatingEffect();
        handleCardActivation();

        // Add occasional ambient scanning effect
        setInterval(() => {
          if (Math.random() > 0.5) {
            animateActiveCard();
          }
        }, 8000);
      }, 500);
    };
  </script>
  <body>
    <div class="carousel-container">
      <div class="carousel-track">
        <div class="carousel-card">
          <div class="card-image-container">
            <img
              src="https://picsum.photos/320/200?t=1"
              alt="Synthwave City"
              class="card-image"
            />
          </div>
          <div class="card-content">
            <h3
              class="card-title text-xl font-bold text-cyan-400"
              data-text="Project Alpha"
            >
              Project Alpha
            </h3>
            <p class="card-description">
              Exploring the neon-drenched landscapes of a digital frontier.
              AI-driven procedural generation creates infinite cityscapes.
            </p>
            <div class="card-progress">
              <div class="progress-value" style="width: 65%"></div>
            </div>
            <div class="card-stats">
              <span>PHASE II</span>
              <span>65% COMPLETE</span>
            </div>
          </div>
          <div class="tech-details">
            <div class="tech-tag">Neural Networks</div>
            <div class="tech-tag">Voxel Systems</div>
            <div class="tech-tag">Quantum Rendering</div>
          </div>
        </div>

        <div class="carousel-card">
          <div>
            <div class="card-image-container">
              <img
                src="https://picsum.photos/320/200?t=2"
                alt="Neuro Interface"
                class="card-image"
              />
            </div>
            <div class="card-content">
              <h3
                class="card-title text-xl font-bold text-blue-400"
                data-text="Neuro-Link UI"
              >
                Neuro-Link UI
              </h3>
              <p class="card-description">
                Designing intuitive interfaces for brain-computer interaction.
                Holographic elements respond to neural patterns.
              </p>
              <div class="card-progress">
                <div class="progress-value" style="width: 42%"></div>
              </div>
              <div class="card-stats">
                <span>PHASE I</span>
                <span>42% COMPLETE</span>
              </div>
            </div>
            <div class="tech-details">
              <div class="tech-tag">BCI Framework</div>
              <div class="tech-tag">Gesture Recognition</div>
              <div class="tech-tag">Thought Mapping</div>
            </div>
          </div>
        </div>

        <div class="carousel-card">
          <div class="card-image-container">
            <img
              src="https://picsum.photos/320/200?t=3"
              alt="Quantum Core"
              class="card-image"
            />
          </div>
          <div class="card-content">
            <h3
              class="card-title text-xl font-bold text-purple-400"
              data-text="Quantum Entanglement"
            >
              Quantum Entanglement
            </h3>
            <p class="card-description">
              Visualizing complex quantum states through advanced rendering
              techniques. Real-time simulation of parallel realities.
            </p>
            <div class="card-progress">
              <div class="progress-value" style="width: 89%"></div>
            </div>
            <div class="card-stats">
              <span>PHASE III</span>
              <span>89% COMPLETE</span>
            </div>
          </div>
          <div class="tech-details">
            <div class="tech-tag">Q-Bit Architecture</div>
            <div class="tech-tag">Multiverse Modeling</div>
            <div class="tech-tag">Probability Fields</div>
          </div>
        </div>

        <div class="carousel-card">
          <div class="card-image-container">
            <img
              src="https://picsum.photos/320/200?t=4"
              alt="Orbital Station"
              class="card-image"
            />
          </div>
          <div class="card-content">
            <h3
              class="card-title text-xl font-bold text-amber-400"
              data-text="Project Chimera"
            >
              Project Chimera
            </h3>
            <p class="card-description">
              Developing next-gen propulsion systems for deep space exploration.
              Fusion drive concepts push beyond known physics.
            </p>
            <div class="card-progress">
              <div class="progress-value" style="width: 51%"></div>
            </div>
            <div class="card-stats">
              <span>PHASE II</span>
              <span>51% COMPLETE</span>
            </div>
          </div>
          <div class="tech-details">
            <div class="tech-tag">Dark Energy Capture</div>
            <div class="tech-tag">Plasma Containment</div>
            <div class="tech-tag">Gravitational Lensing</div>
          </div>
        </div>

        <div class="carousel-card">
          <div class="card-image-container">
            <img
              src="https://picsum.photos/320/200?t=5"
              alt="Data Stream"
              class="card-image"
            />
          </div>
          <div class="card-content">
            <h3
              class="card-title text-xl font-bold text-emerald-400"
              data-text="Aether Network"
            >
              Aether Network
            </h3>
            <p class="card-description">
              Building a decentralized data network leveraging quantum
              blockchain and next-gen P2P technology.
            </p>
            <div class="card-progress">
              <div class="progress-value" style="width: 78%"></div>
            </div>
            <div class="card-stats">
              <span>PHASE III</span>
              <span>78% COMPLETE</span>
            </div>
          </div>
          <div class="tech-details">
            <div class="tech-tag">Quantum Encryption</div>
            <div class="tech-tag">Self-Healing Nodes</div>
            <div class="tech-tag">Data Holograms</div>
          </div>
        </div>
      </div>

      <button class="carousel-button prev">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          stroke-width="1.5"
          stroke="currentColor"
          class="w-6 h-6"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            d="M15.75 19.5 8.25 12l7.5-7.5"
          />
        </svg>
      </button>
      <button class="carousel-button next">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          stroke-width="1.5"
          stroke="currentColor"
          class="w-6 h-6"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            d="m8.25 4.5 7.5 7.5-7.5 7.5"
          />
        </svg>
      </button>

      <div class="carousel-indicators">
        <div class="indicator active"></div>
        <div class="indicator"></div>
        <div class="indicator"></div>
        <div class="indicator"></div>
        <div class="indicator"></div>
      </div>
    </div>
  </body>
</head>
